"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.positionTree = void 0;
var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));
var _constants = require("../constants");
/**
 * position the tree nodes x and y coordinates.
 * @param root 
 * @returns 
 */
var positionTree = function positionTree(root) {
  // create a super root to handle the positioning of the root node and its groups
  var superRoot = {
    data: root.data,
    children: [root]
  };

  // create a stack to traverse the tree
  var stack = [];

  // push the super root to the stack
  stack.push({
    parentSpan: 0,
    currentIndex: 0,
    parentX: -_constants.NODE_WIDTH / 2,
    siblingSpan: [],
    route: superRoot
  });

  // traverse the tree
  var _loop = function _loop() {
    var _route$children;
    // get the current node from the stack
    var stackValue = stack.pop();
    var _ref = stackValue,
      parentSpan = _ref.parentSpan,
      currentIndex = _ref.currentIndex,
      siblingSpan = _ref.siblingSpan,
      parentX = _ref.parentX,
      route = _ref.route;

    // logic to calculate the x and y coordinates of the node
    var siblingsCurrentSpan = siblingSpan.slice(0).reduce(function (acc, curr, index) {
      return index < currentIndex ? acc + curr : acc;
    }, 0);
    route.data.x = parentX - parentSpan / 2 + siblingsCurrentSpan + route.data.spanSize / 2 + _constants.NODE_SPACING_X * currentIndex;
    route.data.y = route.data.depth * (_constants.NODE_SPACING_Y + _constants.NODE_HEIGHT);

    //! below is the logic to keep traversing the tree
    // first get the children without the groups
    var childrenNotGroup = route === null || route === void 0 ? void 0 : (_route$children = route.children) === null || _route$children === void 0 ? void 0 : _route$children.filter(function (child) {
      return child.data.type !== 'Group';
    });
    if (childrenNotGroup === undefined) return "continue";

    // then get the groups from the groups you just got (since they are on the same depth)
    var childrenGroups = [];
    childrenNotGroup.forEach(function (route) {
      var _route$children2;
      var routeGroups = (_route$children2 = route.children) === null || _route$children2 === void 0 ? void 0 : _route$children2.filter(function (child) {
        return child.data.type === 'Group';
      });
      routeGroups === null || routeGroups === void 0 ? void 0 : routeGroups.forEach(function (group) {
        childrenGroups.push(group);
      });
    });

    // merge the two arrays (children and groups)
    var children = [].concat((0, _toConsumableArray2["default"])(childrenNotGroup), childrenGroups);

    // sort the array by the route data.path (to allow the groups to be next to their parent route)
    children.sort(function (a, b) {
      return a.data.path.localeCompare(b.data.path);
    });

    // reverse the array to get the correct order and push to the stack for traversal
    children.reverse();
    var childrenSpans = children.map(function (child) {
      return child.data.spanSize;
    }).reverse();
    children.forEach(function (child, index) {
      return stack.push({
        parentSpan: route.data.spanSize,
        currentIndex: children.length - index - 1,
        siblingSpan: childrenSpans,
        parentX: route.data.x,
        route: child
      });
    });
  };
  while (stack.length) {
    var _ret = _loop();
    if (_ret === "continue") continue;
  }
  return root;
};
exports.positionTree = positionTree;