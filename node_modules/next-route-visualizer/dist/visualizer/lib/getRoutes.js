"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getRoutes = void 0;
var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));
var _fs = _interopRequireDefault(require("fs"));
var _crypto = require("crypto");
var _constants = require("../constants");
var _utils = require("../utils");
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
/**
 * Get the routes from a path. If no path is provided, it will try to find the app directory
 * @param path - path to get routes from
 * @returns 
 */
var getRoutes = function getRoutes(path, baseURL) {
  var _baseURL;
  baseURL = (_baseURL = baseURL) !== null && _baseURL !== void 0 ? _baseURL : _constants.FALLBACK_BASE_URL;
  if (!path || path === '') {
    try {
      (0, _utils.isDirectory)('./app');
      return getRoutesHelper('./app', baseURL);
    } catch (error) {
      // console.log('No ./app directory found')
    }
    try {
      (0, _utils.isDirectory)('./src/app');
      return getRoutesHelper('./src/app', baseURL);
    } catch (error) {
      // console.log('No ./src/app directory found')
    }
    throw new Error('No app directory found and no path provided');
  }
  try {
    var relativePath = "./app/".concat(path);
    if (!(0, _utils.isDirectory)(relativePath)) throw new Error('Path is valid for ./app');
    return getRoutesHelper(relativePath, "".concat(baseURL, "/").concat((0, _utils.pathFromRoot)(relativePath)));
  } catch (error) {
    // console.log(error)
  }
  try {
    var _relativePath = "./src/app/".concat(path);
    if (!(0, _utils.isDirectory)(_relativePath)) throw new Error('Path is valid for ./src/app');
    return getRoutesHelper(_relativePath, "".concat(baseURL, "/").concat((0, _utils.pathFromRoot)(_relativePath)));
  } catch (error) {
    // console.log(error)
  }
  return {};
};

/**
 * Get all routes from a path recursively
 * @param path
 * @return route
 */
exports.getRoutes = getRoutes;
var getRoutesHelper = function getRoutesHelper(path, link) {
  var depth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  var parentID = arguments.length > 3 ? arguments[3] : undefined;
  try {
    var _path$split$pop, _path$split;
    // Get all elements in the path and split them into folders and files
    var elements = _fs["default"].readdirSync(path);
    var _elements$reduce = elements.reduce(function (acc, element) {
        var fullPath = "".concat(path, "/").concat(element);
        if ((0, _utils.isDirectory)(fullPath)) {
          acc[0].push(element);
          return acc;
        }
        var isClient = (0, _utils.isClientSide)(fullPath);
        if ((0, _utils.isNextFile)(fullPath)) {
          acc[1].push(_objectSpread(_objectSpread({}, (0, _utils.getFileNameExtension)(element)), {}, {
            path: fullPath,
            isClient: isClient
          }));
          return acc;
        }
        acc[2].push(_objectSpread(_objectSpread({}, (0, _utils.getFileNameExtension)(element)), {}, {
          path: fullPath,
          isClient: isClient
        }));
        return acc;
      }, [[], [], []]),
      _elements$reduce2 = (0, _slicedToArray2["default"])(_elements$reduce, 3),
      folders = _elements$reduce2[0],
      nextFiles = _elements$reduce2[1],
      otherFiles = _elements$reduce2[2];
    var isGroup = (0, _utils.isRouteGroup)(path);
    // if the path is a route group, the link should be the parent link
    if (isGroup) link = link.split('/').slice(0, -1).join('/');
    var isSegment = (0, _utils.isRouteSegment)(path);
    // if the path is a route segment, the link should be the parent link + a star
    if (isSegment) link = "".concat(link.split('/').slice(0, -1).join('/'), "/*");

    // create route data
    var routeID = (0, _crypto.createHash)('sha256').update(path).digest('hex');
    var routeName = (_path$split$pop = (_path$split = path.split('/')) === null || _path$split === void 0 ? void 0 : _path$split.pop()) !== null && _path$split$pop !== void 0 ? _path$split$pop : path;
    if (isGroup) depth = depth - 1;
    var data = {
      id: routeID,
      name: routeName,
      path: path,
      link: link,
      depth: depth,
      type: parentID === undefined ? 'Root' : isGroup ? 'Group' : isSegment ? 'Segment' : 'Route',
      // check Colocating later
      parentID: parentID,
      maxSpan: 1,
      spanSize: _constants.NODE_WIDTH,
      directlySpanning: 0,
      nextFiles: nextFiles,
      otherFiles: otherFiles,
      childrenID: (0, _toConsumableArray2["default"])(folders.map(function (folder) {
        return (0, _crypto.createHash)('sha256').update("".concat(path, "/").concat(folder)).digest('hex');
      }))
    };
    var children = (0, _toConsumableArray2["default"])(folders.map(function (folder, index) {
      return getRoutesHelper("".concat(path, "/").concat(folder), "".concat(link, "/").concat(folder), depth + 1, routeID);
    }));

    // create route
    var route = {
      data: data,
      children: children
    };

    // check colocating and set spans. Do this here to avoid traversing the tree later. 
    route = (0, _utils.isColocating)(route);
    route = (0, _utils.setRouteSpans)(route);
    return route;
  } catch (error) {
    throw new Error("Path: ".concat(path, " is not a valid path \n").concat(error));
  }
};